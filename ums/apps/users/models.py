import random
from django.db import models
from django.db.models import Q
from django.core.exceptions import ValidationError
from django.contrib.auth.models import AbstractUser, Group
from phonenumber_field.modelfields import PhoneNumberField
from apps.organization.models import Faculty, Program
from apps.core.managers import RLSManager
from .managers import UserRLSManager

class User(AbstractUser):
    first_name = models.CharField("first name", max_length=30)
    last_name = models.CharField("last name", max_length=30)
    email = models.EmailField("email address", unique=True, blank=True, null=True)
    phone_number = PhoneNumberField(max_length=16, unique=True, blank=True, null=True)
    faculties = models.ManyToManyField(Faculty, blank = True)
    programs = models.ManyToManyField(Program, blank = True)
    is_professor = models.BooleanField(default=False)

    objects = UserRLSManager()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
    
    def get_user_rls_filter(self, user):
        return Q(username=user__username)

    def save(self, *args, **kwargs):
        """
        First, make sure that if it's a new user, we set an unusable password
        Second, make sure that we can save multiple users with blank email (because the default can't for some reason)
        Third, make sure the username is autogenerated and unique
        Fourth, make sure that if they are staff, then they get added into the staff group
        """
        if self.is_superuser:
            return super().save(*args, **kwargs)

        creation = not self.pk
        if creation:
            self.set_unusable_password()
        
        # check if user exist or not and make the username unique
        self.username = self.first_name + self.last_name
        if creation:
            if User.objects.filter(username=self.username).exists():
                self.username += str(random.randint(0, 10))
        else:
            if User.objects.filter(username=self.username).exclude(pk=self.pk).exists():
                self.username += str(random.randint(0, 10))

        # ensures that we can have the same blank email and phone number
        if self.email == '':
            self.email = None
        if self.phone_number == '':
            self.phone_number = None
                
        # ensure that staff status always in staff n prof group
        staff_group, _ = Group.objects.get_or_create(name="ALL STAFF")
        if self.is_staff:
            self.groups.add(staff_group)
        elif not creation:
            self.groups.remove(staff_group)
        
        professor_group, _ = Group.objects.get_or_create(name="ALL PROFESSOR")
        if self.is_professor:
            self.groups.add(professor_group)
        elif not creation:
            self.groups.remove(professor_group)

        super().save(*args, **kwargs)

    class Meta:
        verbose_name = "User"
        permissions = [
            ("access_global", "Global Access"),
            ("access_faculty_wide", "Faculty Wide Access"),
            ("access_program_wide", "Program Wide Access"),
        ]

class Student(models.Model):
    user = models.ForeignKey(User, on_delete=models.PROTECT)
    _class = models.ForeignKey('academic.Class', on_delete=models.SET_NULL, related_name="students", null=True, blank=True)
    
    objects = RLSManager(field_with_affiliation='_class')
    
    class Meta:
        unique_together = ('_class', 'user')
    
    def __str__(self):
        return self.user.__str__()
    
    def clean(self):
        _class = self._class
        if _class and hasattr(self, 'faculty') and hasattr(self, 'program') and \
            (_class.faculty != self.faculty or _class.program != self.program):
            raise ValidationError("Class must belong to the same faculty and program as the student.")

    def save(self, *args, **kwargs):
        """
        last resort: ensure affiliation integrity by overriding the user input
        also add them to the all student grp
        """
        if self._class:
            self.faculty = self._class.faculty
            self.program = self._class.program
        
        student_group, _ = Group.objects.get_or_create(name="ALL STUDENT")
        self.user.groups.add(student_group)
        
        super().save(*args, **kwargs)
    
    def delete(self, *args, **kwargs):
        # remove the user if they don't have any more profile associated (ONLY FOR STUDENT) for clean up purpose
        # remove the user from the student grp
        if self.user.groups.count() == 1 and \
            self.user.user_permissions.count() == 0 and \
            not Student.objects.filter(user=self.user).exclude(pk=self.pk).exists():
            # do this to bypass the on_delete protection
            Student._meta.get_field('user').remote_field.on_delete = models.CASCADE
            self.user.delete()
            Student._meta.get_field('user').remote_field.on_delete = models.PROTECT
        
        student_group, _ = Group.objects.get_or_create(name="ALL STUDENT")
        if self.user.pk:
            self.user.groups.remove(student_group)

        super().delete(*args, **kwargs)
    
    def get_user_rls_filter(self, user):
        return Q(user=user)