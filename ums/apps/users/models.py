import random
from django.db import models
from django.db.models import Q
from django.core.exceptions import ValidationError
from django.contrib.auth.models import AbstractUser, Group
from phonenumber_field.modelfields import PhoneNumberField
from apps.organization.models import Faculty, Program
from apps.core.managers import RLSManager
from .managers import UserRLSManager

class User(AbstractUser):
    first_name = models.CharField("first name", max_length=30)
    last_name = models.CharField("last name", max_length=30)
    email = models.EmailField("email address", unique=True, blank=True, null=True)
    phone_number = PhoneNumberField(max_length=16, unique=True, blank=True, null=True)
    faculties = models.ManyToManyField(Faculty, blank = True)
    programs = models.ManyToManyField(Program, blank = True)
    is_professor = models.BooleanField(default=False)

    objects = UserRLSManager()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
    
    def get_user_rls_filter(self, user):
        return Q(username=user.username)

    def clean(self):
        """
        First, make sure that if it's a new user, we set an unusable password
        Second, make sure that we can save multiple users with blank email (because the default can't for some reason)
        Third, make sure the username is autogenerated and unique
        Fourth, make sure that if they are staff, then they get added into the staff group
        """
        if self.is_superuser:
            return
        creation = not self.pk
        if creation:
            self.set_unusable_password()
        
        # check if user exist or not and make the username unique
        self.username = self.first_name + self.last_name
        if creation:
            if User.objects.filter(username=self.username).exists():
                self.username += str(random.randint(0, 10))
        else:
            if User.objects.filter(username=self.username).exclude(pk=self.pk).exists():
                self.username += str(random.randint(0, 10))

        # ensures that we can have the same blank email and phone number
        if self.email == '':
            self.email = None
        if self.phone_number == '':
            self.phone_number = None
                
        # ensure that staff status always in staff n prof group
        staff_group, _ = Group.objects.get_or_create(name="STAFF")
        if self.is_staff:
            self.groups.add(staff_group)
        elif not creation:
            self.groups.remove(staff_group)
        
        professor_group, _ = Group.objects.get_or_create(name="PROFESSOR")
        if self.is_professor:
            self.groups.add(professor_group)
        elif not creation:
            self.groups.remove(professor_group)
    
    def save(self, *args, **kwargs):
        self.clean()
        return super().save(*args, **kwargs)
        
    class Meta:
        verbose_name = "User"
        permissions = [
            ("access_global", "Global Access"),
            ("access_faculty_wide", "Faculty Wide Access"),
            ("access_program_wide", "Program Wide Access"),
        ]

class Student(models.Model):
    user = models.ForeignKey(User, on_delete=models.PROTECT)
    _class = models.ForeignKey('academic.Class', on_delete=models.SET_NULL, related_name="students", null=True, blank=True)
    
    objects = RLSManager(field_with_affiliation='_class')
    
    class Meta:
        unique_together = ('_class', 'user')
    
    def __str__(self):
        return self.user.__str__()
    
    def clean(self):
        if hasattr(self, 'user'):
            student_group, _ = Group.objects.get_or_create(name="STUDENT")
            self.user.groups.add(student_group)
    
    def save(self, *args, **kwargs):
        commit = kwargs.pop('commit', None)
        self.clean()
        if commit:
            super().save()
    
    def delete(self, *args, **kwargs):
        # remove the user from the student grp
        if self.user.groups.count() == 1 and \
            self.user.user_permissions.count() == 0 and \
            not Student.objects.filter(user=self.user).exclude(pk=self.pk).exists():
            # do this to bypass the on_delete protection
            Student._meta.get_field('user').remote_field.on_delete = models.CASCADE
            self.user.delete()
            Student._meta.get_field('user').remote_field.on_delete = models.PROTECT
        
        student_group, _ = Group.objects.get_or_create(name="STUDENT")
        if self.user.pk:
            self.user.groups.remove(student_group)

        super().delete(*args, **kwargs)
    
    def get_user_rls_filter(self, user):
        return Q(user=user)